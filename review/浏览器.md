# 浏览器是如何渲染UI的？
+ 浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree
+ 与此同时，进行CSS解析，生成Style Rules
+ 接着将DOM Tree与Style Rules合成为 Render Tree
+ 接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标
+ 随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来

# 浏览器缓存
优点：
+ 减少了不必要的数据传输，节省带宽
+ 减少服务器的负担，提升网站性能
+ 加快了客户端加载网页的速度
+ 用户体验友好
浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：
1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。
    `Cache-Control: no-store` 禁止缓存
    `Cache-Control: no-cache` 强制所有缓存了该响应的用户，但在使用已缓存的数据前，发送带验证器的请求到服务器验证后使用
2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息（返回304）浏览器继续从缓存加载资源。
    `Last-Modify（服务器返回）/If-Modify-Since(浏览器第二次请求)` 根据修改时间来判断
    `ETag（服务器返回）/If-None-Match(浏览器第二次请求)` 根据文件hash值来判断
3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存

# CDN
1. 资源就近原则：加速网站的访问，提高用户体验
2. 安全性高：当某个节点发生故障时可以从邻近的节点获取服务
3. 费用低：用户达到一定规模后，比买高配置服务器费用低很多
4. 覆盖性广：全球覆盖，实现跨运营商、跨地域的全网覆盖

### 回流和重绘
+ html 加载时发生了什么
在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。
浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体
DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。
+ 什么是回流
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。
+ 什么是重绘
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。
+ 区别：
他们的区别很大：回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流。当页面布局和几何属性改变时就需要回流。比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变
