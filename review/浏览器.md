# 浏览器是如何渲染 UI 的？

- 浏览器获取 HTML 文件，然后对文件进行解析，形成 DOM Tree
- 与此同时，进行 CSS 解析，生成 Style Rules
- 接着将 DOM Tree 与 Style Rules 合成为 Render Tree
- 接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标
- 随后调用 GPU 进行绘制（Paint），遍历 Render Tree 的节点，并将元素呈现出来

# 浏览器缓存

优点：

- 减少了不必要的数据传输，节省带宽
- 减少服务器的负担，提升网站性能
- 加快了客户端加载网页的速度
- 用户体验友好
  浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：

1. 浏览器先根据这个资源的 http 头信息来判断是否命中强缓存。如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。强缓存是利用 http 的返回头中的 Expires 或者 Cache-Control 两个字段来控制的，用来表示资源的缓存时间。
   `Cache-Control: no-store` 禁止缓存
   `Cache-Control: no-cache` 强制所有缓存了该响应的用户，但在使用已缓存的数据前，发送带验证器的请求到服务器验证后使用
2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息（返回 304）浏览器继续从缓存加载资源。
   `Last-Modify（服务器返回）/If-Modify-Since(浏览器第二次请求)` 根据修改时间来判断
   `ETag（服务器返回）/If-None-Match(浏览器第二次请求)` 根据文件 hash 值来判断
3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存

# CDN

1. 资源就近原则：加速网站的访问，提高用户体验
2. 安全性高：当某个节点发生故障时可以从邻近的节点获取服务
3. 费用低：用户达到一定规模后，比买高配置服务器费用低很多
4. 覆盖性广：全球覆盖，实现跨运营商、跨地域的全网覆盖

### 回流和重绘

- html 加载时发生了什么
  在页面加载时，浏览器把获取到的 HTML 代码解析成 1 个 DOM 树，DOM 树里包含了所有 HTML 标签，包括 display:none 隐藏，还有用 JS 动态添加的元素等。
  浏览器把所有样式(用户定义的 CSS 和用户代理)解析成样式结构体
  DOM Tree 和样式结构体组合后构建 render tree, render tree 类似于 DOM tree，但区别很大，因为 render tree 能识别样式，render tree 中每个 NODE 都有自己的 style，而且 render tree 不包含隐藏的节点(比如 display:none 的节点，还有 head 节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree 中。我自己简单的理解就是 DOM Tree 和我们写的 CSS 结合在一起之后，渲染出了 render tree。
- 什么是回流
  当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建 render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。
- 什么是重绘
  当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。
- 区别：
  他们的区别很大：回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流。当页面布局和几何属性改变时就需要回流。比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

1、浏览器地址栏输入 url

2、浏览器会先查看浏览器缓存--系统缓存--路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步

3、域名解析（DNS）获取相应的 ip

4、浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手

5、握手成功，浏览器向服务器发送 http 请求，请求数据包

6、服务器请求数据，将数据返回到浏览器

7、浏览器接收响应，读取页面内容，解析 html
